import { Command, flags } from '@oclif/command';
import { Canvas, createCanvas } from 'canvas';
import * as fs from 'fs-extra';

export default class Image extends Command {
  public static description = 'convert generated Box2D shape data to an image for debugging';

  public static flags = {
    help: flags.help({ char: 'h' }),
    overwrite: flags.boolean({
      char: 'o',
      description: 'overwrite the output file if it exists',
      default: false,
    }),
  };

  public static args = [
    {
      name: 'input',
      description: 'path to JSON file containing shape data generated by the `generate` command',
      required: true,
    },
    {
      name: 'output',
      description: 'where the generated PNG image should be placed',
      required: true,
    },
  ];

  public async run(): Promise<void> {
    // tslint:disable-next-line:no-shadowed-variable
    const { args, flags } = this.parse(Image);

    const inputExists = await fs.pathExists(args.input);
    if (inputExists) {
      const stat = await fs.stat(args.input);
      if (!stat.isFile()) {
        this.error('The input path does not point to a file', { exit: 1 });
      }
    } else {
      this.error('The input path does not exist', { exit: 1 });
    }

    if (!flags.overwrite) {
      const outputExists = await fs.pathExists(args.output);
      if (outputExists) {
        this.error('The output file already exists, use --overwrite to overwrite it', { exit: 1 });
      }
    }

    await this.generateImage(args.input, args.output);
  }

  private async generateImage(inputPath: string, outputPath: string): Promise<void> {
    const inputBuffer = await fs.readFile(inputPath);
    const inputData = JSON.parse(inputBuffer.toString());
    const shapes: Array<Array<[Point, Point, Point]>> = inputData.shapes;

    const width = Math.max(
      ...shapes.map(triangleList => {
        return Math.max(
          ...triangleList.map(triangle => {
            return Math.max(...triangle.map(point => point.x));
          }),
        );
      }),
    );

    const height = Math.max(
      ...shapes.map(triangleList => {
        return Math.max(
          ...triangleList.map(triangle => {
            return Math.max(...triangle.map(point => point.y));
          }),
        );
      }),
    );

    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    ctx.strokeStyle = 'rgba(0, 0, 0, 1.0)';
    ctx.fillStyle = 'rgba(173, 216, 230, 1.0)';

    for (const triangleList of shapes) {
      for (const triangle of triangleList) {
        ctx.beginPath();

        for (let i = 0; i < triangle.length; i++) {
          const { x, y } = triangle[i];

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.closePath();

        ctx.stroke();
        ctx.fill();
      }
    }

    await fs.ensureFile(outputPath);
    await fs.writeFile(outputPath, canvas.toBuffer('image/png'));
  }
}
